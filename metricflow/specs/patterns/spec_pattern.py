from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Generic, Optional, Sequence, TypeVar

from dbt_semantic_interfaces.pretty_print import pformat_big_objects

from metricflow.instances import SpecT
from metricflow.specs.patterns.similarity import top_fuzzy_matches
from metricflow.specs.specs import InstanceSpec


class SpecPattern(ABC, Generic[SpecT]):
    """A pattern is used to select a spec from a group of specs based on class-defined criteria."""

    @abstractmethod
    def score(self, candidate_specs: Sequence[SpecT]) -> ScoringResults:
        """Given a sequence of instance specs, try to match them to this pattern and return the associated scores."""
        pass

    @property
    @abstractmethod
    def naming_scheme(self) -> QueryItemNamingScheme[SpecT]:
        """The naming scheme used for this pattern. Used to generate suggestions in error messages."""
        pass

    @staticmethod
    def make_scoring_results(
        matching_specs: Sequence[InstanceSpec],
        non_matching_specs: Sequence[InstanceSpec],
        input_str: str,
        naming_scheme: QueryItemNamingScheme,
    ) -> ScoringResults:
        """Creates a result where matching specs are given a score of 1.0 and the rest are scored by edit distance.

        The edit distance is between input_str and the input strings generated by the naming scheme for the non-matching
        specs. This is useful for generating suggestions in error messages.

        The result is returned in order with the highest scores first.
        """
        scored_specs = []
        for matching_spec in matching_specs:
            scored_specs.append(
                ScoredSpec(
                    spec=matching_spec,
                    score=1.0,
                )
            )

        # For all non-matching specs, score them based on the edit distance.
        non_matching_spec_name_to_spec = {}
        for spec in non_matching_specs:
            input_str_for_spec = naming_scheme.input_str(spec)
            if input_str_for_spec is not None:
                non_matching_spec_name_to_spec[input_str_for_spec] = spec

        top_scored_items = sorted(
            top_fuzzy_matches(
                item=input_str,
                candidate_items=tuple(non_matching_spec_name_to_spec.keys()),
            ),
            key=lambda item: -item.score,
        )

        for scored_item in top_scored_items:
            scored_specs.append(
                ScoredSpec(spec=non_matching_spec_name_to_spec[scored_item.item_str], score=scored_item.score)
            )

        return ScoringResults(scored_specs=tuple(scored_specs))


@dataclass
class ScoredSpec:
    """The result of matching a spec pattern to a spec."""

    # The spec associated with the score.
    spec: InstanceSpec
    # A float indicating how well the spec matches the pattern. A score > 0 indicates that the spec matches
    # the pattern. A score <= 0 indicates that the spec does not match the pattern, but the more negative it is,
    # the worse the match. This is used to rank suggestions when a user-provided spec pattern does not match any
    # know specs. e.g. a spec pattern made from user input that is supposed to match a metric with a specific name
    # may not produce a match if there is a typo. This score can be used with the pattern to provided suggestions
    # based on known metric names.
    score: float

    @property
    def matches(self) -> bool:  # noqa: D
        return self.score > 0.0


SelfTypeT = TypeVar("SelfTypeT", bound="SpecPattern")


@dataclass(frozen=True)
class ScoringResults:
    """The results of matching a pattern to a set of specs."""

    scored_specs: Sequence[ScoredSpec]

    @property
    def matched_specs(self) -> Sequence[InstanceSpec]:  # noqa: D
        return tuple(scored_spec.spec for scored_spec in self.scored_specs if scored_spec.matches)

    @property
    def has_exactly_one_match(self) -> bool:  # noqa: D
        return len(self.matched_specs) == 1

    @property
    def matching_spec(self) -> InstanceSpec:
        """If there is exactly one spec that matched, return it. Otherwise, raise a RuntimeError."""
        matched_specs = self.matched_specs
        if len(matched_specs) != 1:
            raise RuntimeError(f"This result not contain exactly 1 match. Got:\n{pformat_big_objects(matched_specs)}")
        return matched_specs[0]


class QueryItemNamingScheme(ABC, Generic[SpecT]):
    """Describes how to name items that are involved in a MetricFlow query.

    Items in a query can be anything that is associated with a spec, for example metrics and group by items.
    These items can be described in different string representations like "user__country" or
    "TimeDimension('metric_time', 'DAY')".

    The generic parameter SpecT determines the types of instance specs that this naming scheme applies to.
    """

    @abstractmethod
    def input_str(self, instance_spec: SpecT) -> Optional[str]:
        """Following this scheme, return the string that can be used as an input that would specify the given spec.

        If this scheme cannot accommodate the spec, return None. This is needed to handle a case with DatePart in
        DunderNamingScheme, but naming schemes should otherwise be complete.
        """
        pass

    @abstractmethod
    def output_column_name(self, instance_spec: SpecT) -> Optional[str]:
        """Following this scheme, return the name of the column containing the item with the given spec.

        Returns None if this naming scheme can't generate a column name for the given spec. (PythonObjectNamingScheme
        does not yet support use in generating column names)
        """
        pass

    @abstractmethod
    def spec_pattern(self, input_str: str) -> SpecPattern[SpecT]:
        """Given an the input follows this scheme, return a spec pattern that matches the defined behavior."""
        pass

    @abstractmethod
    def input_str_follows_scheme(self, input_str: str) -> bool:
        """Returns true if the given input string follows this naming scheme."""
        pass

    @property
    @abstractmethod
    def input_str_description(self) -> str:
        """A description of this naming scheme used in error messages."""
        pass
